<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DanilovSoft.vRPC</name>
    </assembly>
    <members>
        <member name="T:DanilovSoft.vRPC.ActionContext">
            <summary>
            Контекст запроса.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.ActionContext.Id">
            <summary>
            Идентификатор запроса.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.ActionContext.ResponseBuffer">
            <summary>
            Буфер арендованной памяти для записи ответа.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.ActionContext.Method">
            <summary>
            Может быть <see langword="null"/> если не удалось разобрать запрос.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ActionContext.#ctor(System.Nullable{System.Int32},DanilovSoft.vRPC.ControllerMethodMeta,DanilovSoft.vRPC.ArrayBufferWriter{System.Byte})">
            <summary>
            
            </summary>
            <param name="id"></param>
            <param name="method">Может быть Null если не удалось разобрать запрос.</param>
            <param name="responseBuffer"></param>
        </member>
        <member name="T:DanilovSoft.vRPC.InternalErrorResult">
            <summary>
            Код ошибки -32603, аналогично 500.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.InternalErrorResult.#ctor(System.String)">
            <summary>
            Код ошибки -32603, аналогично 500.
            </summary>
        </member>
        <member name="T:DanilovSoft.vRPC.OkResult">
            <summary>
            Пустой результат с кодом Ok.
            </summary>
        </member>
        <member name="T:DanilovSoft.vRPC.ControllerContractAttribute">
            <summary>
            Указывает имя контроллера к которому будут осуществляться вызовы через помеченный интерфейс.
            </summary>
        </member>
        <member name="T:DanilovSoft.vRPC.NotificationAttribute">
            <summary>
            Метод помеченный атрибутом Notification не ожидает результата.
            Возвращаемый тип метода должен быть void или Task или ValueTask.
            </summary>
        </member>
        <member name="T:DanilovSoft.vRPC.TcpNoDelayAttribute">
            <summary>
            Отключает алгоритм Нейгла при отправке запроса или ответа.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.BearerToken.AccessToken">
            <summary>
            Зашифрованное тело токена.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.BearerToken.ExpiresAt">
            <summary>
            Время актуальности токена.
            </summary>
        </member>
        <member name="T:DanilovSoft.vRPC.RijndaelEnhanced">
            <summary>
            This class uses a symmetric key algorithm (Rijndael/AES) to encrypt and
            decrypt data. As long as it is initialized with the same constructor
            parameters, the class will use the same key. Before performing encryption,
            the class can prepend random bytes to plain text and generate different
            encrypted values from the same plain text, encryption key, initialization
            vector, and other parameters. This class is thread-safe.
            </summary>
            <remarks>
            Be careful when performing encryption and decryption. There is a bug
            ("feature"?) in .NET Framework, which causes corruption of encryptor/
            decryptor if a cryptographic exception occurs during encryption/
            decryption operation. To correct the problem, re-initialize the class
            instance when a cryptographic exception occurs.
            </remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.RijndaelEnhanced.#ctor(System.String)">
            <summary>
            Use this constructor if you are planning to perform encryption/
            decryption with 256-bit key, derived using 1 password iteration,
            hashing without salt, no initialization vector, electronic codebook
            (ECB) mode, SHA-1 hashing algorithm, and 4-to-8 byte long salt.
            </summary>
            <param name="passPhrase">
            Passphrase from which a pseudo-random password will be derived.
            The derived password will be used to generate the encryption key.
            Passphrase can be any string. In this example we assume that the
            passphrase is an ASCII string. Passphrase value must be kept in
            secret.
            </param>
            <remarks>
            This constructor is not recommended because it does not use
            initialization vector and uses the ECB cipher mode, which is less
            secure than the CBC mode.
            </remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.RijndaelEnhanced.#ctor(System.String,System.String)">
            <summary>
            Use this constructor if you are planning to perform encryption/
            decryption with 256-bit key, derived using 1 password iteration,
            hashing without salt, cipher block chaining (CBC) mode, SHA-1
            hashing algorithm, and 4-to-8 byte long salt.
            </summary>
            <param name="passPhrase">
            Passphrase from which a pseudo-random password will be derived.
            The derived password will be used to generate the encryption key.
            Passphrase can be any string. In this example we assume that the
            passphrase is an ASCII string. Passphrase value must be kept in
            secret.
            </param>
            <param name="initVector">
            Initialization vector (IV). This value is required to encrypt the
            first block of plaintext data. For RijndaelManaged class IV must be
            exactly 16 ASCII characters long. IV value does not have to be kept
            in secret.
            </param>
        </member>
        <member name="M:DanilovSoft.vRPC.RijndaelEnhanced.#ctor(System.String,System.String,System.Int32)">
            <summary>
            Use this constructor if you are planning to perform encryption/
            decryption with 256-bit key, derived using 1 password iteration,
            hashing without salt, cipher block chaining (CBC) mode, SHA-1 
            hashing algorithm, and 0-to-8 byte long salt.
            </summary>
            <param name="passPhrase">
            Passphrase from which a pseudo-random password will be derived.
            The derived password will be used to generate the encryption key
            Passphrase can be any string. In this example we assume that the
            passphrase is an ASCII string. Passphrase value must be kept in
            secret.
            </param>
            <param name="initVector">
            Initialization vector (IV). This value is required to encrypt the
            first block of plaintext data. For RijndaelManaged class IV must be
            exactly 16 ASCII characters long. IV value does not have to be kept
            in secret.
            </param>
            <param name="minSaltLen">
            Min size (in bytes) of randomly generated salt which will be added at
            the beginning of plain text before encryption is performed. When this
            value is less than 8, the default min value will be used (currently 8
            bytes).
            </param>
        </member>
        <member name="M:DanilovSoft.vRPC.RijndaelEnhanced.#ctor(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Use this constructor if you are planning to perform encryption/
            decryption with 256-bit key, derived using 1 password iteration,
            hashing without salt, cipher block chaining (CBC) mode, SHA-1
            hashing algorithm. Use the minSaltLen and maxSaltLen parameters to
            specify the size of randomly generated salt.
            </summary>
            <param name="passPhrase">
            Passphrase from which a pseudo-random password will be derived.
            The derived password will be used to generate the encryption key.
            Passphrase can be any string. In this example we assume that the
            passphrase is an ASCII string. Passphrase value must be kept in
            secret.
            </param>
            <param name="initVector">
            Initialization vector (IV). This value is required to encrypt the
            first block of plaintext data. For RijndaelManaged class IV must be
            exactly 16 ASCII characters long. IV value does not have to be kept
            in secret.
            </param>
            <param name="minSaltLen">
            Min size (in bytes) of randomly generated salt which will be added at
            the beginning of plain text before encryption is performed. When this
            value is less than 8, the default min value will be used (currently 8
            bytes).
            </param>
            <param name="maxSaltLen">
            Max size (in bytes) of randomly generated salt which will be added at
            the beginning of plain text before encryption is performed. When this
            value is negative or greater than 255, the default max value will be
            used (currently 8 bytes). If max value is 0 (zero) or if it is smaller
            than the specified min value (which can be adjusted to default value),
            salt will not be used and plain text value will be encrypted as is.
            In this case, salt will not be processed during decryption either.
            </param>
        </member>
        <member name="M:DanilovSoft.vRPC.RijndaelEnhanced.#ctor(System.String,System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Use this constructor if you are planning to perform encryption/
            decryption using the key derived from 1 password iteration,
            hashing without salt, cipher block chaining (CBC) mode, and
            SHA-1 hashing algorithm.
            </summary>
            <param name="passPhrase">
            Passphrase from which a pseudo-random password will be derived.
            The derived password will be used to generate the encryption key.
            Passphrase can be any string. In this example we assume that the
            passphrase is an ASCII string. Passphrase value must be kept in
            secret.
            </param>
            <param name="initVector">
            Initialization vector (IV). This value is required to encrypt the
            first block of plaintext data. For RijndaelManaged class IV must be
            exactly 16 ASCII characters long. IV value does not have to be kept
            in secret.
            </param>
            <param name="minSaltLen">
            Min size (in bytes) of randomly generated salt which will be added at
            the beginning of plain text before encryption is performed. When this
            value is less than 8, the default min value will be used (currently 8
            bytes).
            </param>
            <param name="maxSaltLen">
            Max size (in bytes) of randomly generated salt which will be added at
            the beginning of plain text before encryption is performed. When this
            value is negative or greater than 255, the default max value will be 
            used (currently 8 bytes). If max value is 0 (zero) or if it is smaller
            than the specified min value (which can be adjusted to default value),
            salt will not be used and plain text value will be encrypted as is.
            In this case, salt will not be processed during decryption either.
            </param>
            <param name="keySize">
            Size of symmetric key (in bits): 128, 192, or 256.
            </param>
        </member>
        <member name="M:DanilovSoft.vRPC.RijndaelEnhanced.#ctor(System.String,System.String,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Use this constructor if you are planning to perform encryption/
            decryption using the key derived from 1 password iteration, and
            cipher block chaining (CBC) mode.
            </summary>
            <param name="passPhrase">
            Passphrase from which a pseudo-random password will be derived.
            The derived password will be used to generate the encryption key.
            Passphrase can be any string. In this example we assume that the
            passphrase is an ASCII string. Passphrase value must be kept in
            secret.
            </param>
            <param name="initVector">
            Initialization vector (IV). This value is required to encrypt the
            first block of plaintext data. For RijndaelManaged class IV must be
            exactly 16 ASCII characters long. IV value does not have to be kept
            in secret.
            </param>
            <param name="minSaltLen">
            Min size (in bytes) of randomly generated salt which will be added at
            the beginning of plain text before encryption is performed. When this
            value is less than 8, the default min value will be used (currently 8
            bytes).
            </param>
            <param name="maxSaltLen">
            Max size (in bytes) of randomly generated salt which will be added at
            the beginning of plain text before encryption is performed. When this
            value is negative or greater than 255, the default max value will be
            used (currently 8 bytes). If max value is 0 (zero) or if it is smaller
            than the specified min value (which can be adjusted to default value),
            salt will not be used and plain text value will be encrypted as is.
            In this case, salt will not be processed during decryption either.
            </param>
            <param name="keySize">
            Size of symmetric key (in bits): 128, 192, or 256.
            </param>
            <param name="saltValue">
            Salt value used for password hashing during key generation. This is
            not the same as the salt we will use during encryption. This parameter
            can be any string.
            </param>
        </member>
        <member name="M:DanilovSoft.vRPC.RijndaelEnhanced.#ctor(System.String,System.String,System.Int32,System.Int32,System.Int32,System.String,System.Int32)">
            <summary>
            Use this constructor if you are planning to perform encryption/
            decryption with the key derived from the explicitly specified
            parameters.
            </summary>
            <param name="passPhrase">
            Passphrase from which a pseudo-random password will be derived.
            The derived password will be used to generate the encryption key
            Passphrase can be any string. In this example we assume that the
            passphrase is an ASCII string. Passphrase value must be kept in
            secret.
            </param>
            <param name="initVector">
            Initialization vector (IV). This value is required to encrypt the
            first block of plaintext data. For RijndaelManaged class IV must be
            exactly 16 ASCII characters long. IV value does not have to be kept
            in secret.
            </param>
            <param name="minSaltLen">
            Min size (in bytes) of randomly generated salt which will be added at
            the beginning of plain text before encryption is performed. When this
            value is less than 8, the default min value will be used (currently 8
            bytes).
            </param>
            <param name="maxSaltLen">
            Max size (in bytes) of randomly generated salt which will be added at
            the beginning of plain text before encryption is performed. When this
            value is negative or greater than 255, the default max value will be
            used (currently 8 bytes). If max value is 0 (zero) or if it is smaller
            than the specified min value (which can be adjusted to default value),
            salt will not be used and plain text value will be encrypted as is.
            In this case, salt will not be processed during decryption either.
            </param>
            <param name="keySize">
            Size of symmetric key (in bits): 128, 192, or 256.
            </param>
            <param name="saltValue">
            Salt value used for password hashing during key generation. This is
            not the same as the salt we will use during encryption. This parameter
            can be any string.
            </param>
            <param name="passwordIterations">
            Number of iterations used to hash password. More iterations are
            considered more secure but may take longer.
            </param>
        </member>
        <member name="M:DanilovSoft.vRPC.RijndaelEnhanced.Encrypt(System.String)">
            <summary>
            Encrypts a string value generating a base64-encoded string.
            </summary>
            <param name="plainText">
            Plain text string to be encrypted.
            </param>
            <returns>
            Cipher text formatted as a base64-encoded string.
            </returns>
        </member>
        <member name="M:DanilovSoft.vRPC.RijndaelEnhanced.Encrypt(System.Byte[])">
            <summary>
            Encrypts a byte array generating a base64-encoded string.
            </summary>
            <param name="plainTextBytes">
            Plain text bytes to be encrypted.
            </param>
            <returns>
            Cipher text formatted as a base64-encoded string.
            </returns>
        </member>
        <member name="M:DanilovSoft.vRPC.RijndaelEnhanced.EncryptToBytes(System.String)">
            <summary>
            Encrypts a string value generating a byte array of cipher text.
            </summary>
            <param name="plainText">
            Plain text string to be encrypted.
            </param>
            <returns>
            Cipher text formatted as a byte array.
            </returns>
        </member>
        <member name="M:DanilovSoft.vRPC.RijndaelEnhanced.EncryptToBytes(System.Span{System.Byte})">
            <summary>
            Encrypts a byte array generating a byte array of cipher text.
            </summary>
            <param name="plainTextBytes">
            Plain text bytes to be encrypted.
            </param>
            <returns>
            Cipher text formatted as a byte array.
            </returns>
        </member>
        <member name="M:DanilovSoft.vRPC.RijndaelEnhanced.Decrypt(System.String)">
            <summary>
            Decrypts a base64-encoded cipher text value generating a string result.
            </summary>
            <param name="cipherText">
            Base64-encoded cipher text string to be decrypted.
            </param>
            <returns>
            Decrypted string value.
            </returns>
        </member>
        <member name="M:DanilovSoft.vRPC.RijndaelEnhanced.Decrypt(System.Byte[])">
            <summary>
            Decrypts a byte array containing cipher text value and generates a
            string result.
            </summary>
            <param name="cipherTextBytes">
            Byte array containing encrypted data.
            </param>
            <returns>
            Decrypted string value.
            </returns>
        </member>
        <member name="M:DanilovSoft.vRPC.RijndaelEnhanced.DecryptToBytes(System.String)">
            <summary>
            Decrypts a base64-encoded cipher text value and generates a byte array
            of plain text data.
            </summary>
            <param name="cipherText">
            Base64-encoded cipher text string to be decrypted.
            </param>
            <returns>
            Byte array containing decrypted value.
            </returns>
        </member>
        <member name="M:DanilovSoft.vRPC.RijndaelEnhanced.DecryptToBytes(System.Byte[])">
            <summary>
            Decrypts a base64-encoded cipher text value and generates a byte array
            of plain text data.
            </summary>
            <param name="cipherTextBytes">
            Byte array containing encrypted data.
            </param>
            <returns>
            Byte array containing decrypted value.
            </returns>
        </member>
        <member name="M:DanilovSoft.vRPC.RijndaelEnhanced.AddSalt(System.Span{System.Byte},System.Span{System.Byte},System.Int32)">
            <summary>
            Adds an array of randomly generated bytes at the beginning of the
            array holding original plain text value.
            </summary>
            <param name="plainTextBytes">
            Byte array containing original plain text value.
            </param>
            <returns>
            Either original array of plain text bytes (if salt is not used) or a
            modified array containing a randomly generated salt added at the 
            beginning of the plain text bytes. 
            </returns>
        </member>
        <member name="M:DanilovSoft.vRPC.RijndaelEnhanced.GenerateSalt(System.Span{System.Byte})">
            <summary>
            Generates an array holding cryptographically strong bytes.
            </summary>
            <remarks>
            Salt size will be defined at random or exactly as specified by the
            minSlatLen and maxSaltLen parameters passed to the object constructor.
            The first four bytes of the salt array will contain the salt length
            split into four two-bit pieces.
            </remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.RijndaelEnhanced.GenerateRandomNumber(System.Int32,System.Int32)">
            <summary>
            Generates random integer.
            </summary>
            <param name="minValue">
            Min value (inclusive).
            </param>
            <param name="maxValue">
            Max value (inclusive).
            </param>
            <returns>
            Random integer value between the min and max values (inclusive).
            </returns>
            <remarks>
            This methods overcomes the limitations of .NET Framework's Random
            class, which - when initialized multiple times within a very short
            period of time - can generate the same "random" number.
            </remarks>
        </member>
        <member name="T:DanilovSoft.vRPC.RijndaelEnhancedTest">
            <summary>
            Illustrates the use of RijndaelEnhanced class to encrypt and decrypt data
            using a random salt value.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.RijndaelEnhancedTest.Main">
            <summary>
            The main entry point for the application.
            </summary>
        </member>
        <member name="T:DanilovSoft.vRPC.VRpcClient">
            <summary>
            Контекст клиентского соединения.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.VRpcClient._connectLock">
            <summary>
            Используется для синхронизации установки соединения.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.VRpcClient._invokeActions">
            <summary>
            Адрес для подключения к серверу.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.VRpcClient._connection">
            <summary>
            Устанавливается в блокировке <see cref="P:DanilovSoft.vRPC.VRpcClient.StateLock"/>.
            Устанавливается в Null при обрыве соединения.
            </summary>
            <remarks><see langword="volatile"/></remarks>
        </member>
        <member name="P:DanilovSoft.vRPC.VRpcClient.Connection">
            <summary>
            Активное соединение. Может быть Null если соединение отсутствует.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.VRpcClient.Completion">
            <summary>
            Завершается если подключение разорвано.
            Не бросает исключения.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.VRpcClient._shutdownRequest">
            <summary>
            Запись через блокировку <see cref="P:DanilovSoft.vRPC.VRpcClient.StateLock"/>.
            </summary>
            <remarks><see langword="volatile"/> служит для публичного доступа.</remarks>
        </member>
        <member name="P:DanilovSoft.vRPC.VRpcClient.StopRequiredState">
            <summary>
            Если был начат запрос на остновку, то это свойство будет содержать переданную причину остановки.
            Является <see langword="volatile"/>.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.VRpcClient.StateLock">
            <summary>
            Для доступа к <see cref="F:DanilovSoft.vRPC.VRpcClient._disposed"/> и <see cref="F:DanilovSoft.vRPC.VRpcClient._shutdownRequest"/>.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.VRpcClient._connectingWs">
            <summary>
            Используется только что-бы аварийно прервать подключение через Dispose.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.VRpcClient.IsAuthenticated">
            <summary>
            True если соединение прошло аутентификацию на сервере.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.#ctor(System.Uri,System.Boolean)">
            <summary>
            Создаёт контекст клиентского соединения.
            </summary>
            <param name="allowAutoConnect">Разрешено ли интерфейсам самостоятельно устанавливать и повторно переподключаться к серверу.</param>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.#ctor(System.String,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Создаёт контекст клиентского соединения.
            </summary>
            <param name="allowAutoConnect">Разрешено ли интерфейсам самостоятельно устанавливать и повторно переподключаться к серверу.</param>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.#ctor(System.Reflection.Assembly,System.Uri,System.Boolean)">
            <summary>
            Конструктор клиента.
            </summary>
            <param name="controllersAssembly">Сборка в которой осуществляется поиск контроллеров.</param>
            <param name="serverAddress">Адрес сервера.</param>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.ConfigureService(System.Action{Microsoft.Extensions.DependencyInjection.ServiceCollection})">
            <summary>
            Позволяет настроить IoC контейнер.
            Выполняется единожды при инициализации подключения.
            </summary>
            <exception cref="T:DanilovSoft.vRPC.VRpcException"/>
            <exception cref="T:System.ArgumentNullException"/>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.Configure(System.Action{DanilovSoft.vRPC.ApplicationBuilder})">
            <exception cref="T:DanilovSoft.vRPC.VRpcException"/>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.ConfigureAutoAuthentication(System.Func{DanilovSoft.vRPC.AccessToken})">
            <exception cref="T:DanilovSoft.vRPC.VRpcException"/>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.WaitCompletion">
            <summary>
            Блокирует поток до завершения <see cref="P:DanilovSoft.vRPC.VRpcClient.Completion"/>.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.Connect">
            <summary>
            Производит предварительное подключение к серверу. Может использоваться для повторного подключения.
            </summary>
            <remarks>Потокобезопасно.</remarks>
            <exception cref="T:DanilovSoft.vRPC.VRpcConnectException"/>
            <exception cref="T:DanilovSoft.vRPC.VRpcShutdownException"/>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.ConnectAsync">
            <summary>
            Производит предварительное подключение к серверу. Может использоваться для повторного переподключения.
            </summary>
            <remarks>Потокобезопасно.</remarks>
            <exception cref="T:DanilovSoft.vRPC.VRpcConnectException"/>
            <exception cref="T:DanilovSoft.vRPC.VRpcShutdownException"/>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.ConnectEx">
            <summary>
            Производит предварительное подключение к серверу. Может использоваться для повторного переподключения.
            Помимо кода возврата может бросить исключение типа <see cref="T:DanilovSoft.vRPC.VRpcConnectException"/>.
            </summary>
            <remarks>Потокобезопасно.</remarks>
            <exception cref="T:DanilovSoft.vRPC.VRpcConnectException"/>
            <exception cref="T:DanilovSoft.vRPC.VRpcShutdownException"/>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.ConnectExAsync">
            <summary>
            Производит предварительное подключение к серверу. Может использоваться для повторного переподключения.
            Помимо кода возврата может бросить исключение типа <see cref="T:DanilovSoft.vRPC.VRpcConnectException"/>.
            </summary>
            <remarks>Потокобезопасно.</remarks>
            <exception cref="T:DanilovSoft.vRPC.VRpcConnectException"/>
            <exception cref="T:DanilovSoft.vRPC.VRpcShutdownException"/>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.SignIn(DanilovSoft.vRPC.AccessToken)">
            <summary>
            Выполняет аутентификацию текущего соединения.
            </summary>
            <param name="accessToken">Аутентификационный токен передаваемый серверу.</param>
            <exception cref="T:DanilovSoft.vRPC.VRpcConnectionNotOpenException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.SignInAsync(DanilovSoft.vRPC.AccessToken)">
            <summary>
            Выполняет аутентификацию текущего соединения.
            </summary>
            <param name="accessToken">Аутентификационный токен передаваемый серверу.</param>
            <exception cref="T:DanilovSoft.vRPC.VRpcConnectionNotOpenException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.SignOut">
            <summary>
            
            </summary>
            <exception cref="T:System.ObjectDisposedException"/>
            <exception cref="T:DanilovSoft.vRPC.VRpcShutdownException"/>
            <exception cref="T:DanilovSoft.vRPC.VRpcConnectionNotOpenException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.SignOutAsync">
            <exception cref="T:DanilovSoft.vRPC.VRpcConnectionNotOpenException"/>
            <exception cref="T:DanilovSoft.vRPC.VRpcShutdownException"/>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.GetProxy``1">
            <summary>
            Создает прокси к методам удалённой стороны на основе интерфейса. Повторное обращение вернет экземпляр из кэша.
            Полученный экземпляр можно привести к типу <see cref="T:DanilovSoft.vRPC.Decorator.ClientInterfaceProxy"/>.
            Метод является шорткатом для <see cref="M:DanilovSoft.vRPC.VRpcClient.GetProxyDecorator``1"/>
            </summary>
            <typeparam name="T">Интерфейс.</typeparam>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.GetProxyDecorator``1">
            <summary>
            Создает прокси к методам удалённой стороны на основе интерфейса. Повторное обращение вернет экземпляр из кэша.
            </summary>
            <typeparam name="T">Интерфейс.</typeparam>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.Shutdown(System.TimeSpan,System.String)">
            <summary>
            Выполняет грациозную остановку. Блокирует поток не дольше чем задано в <paramref name="disconnectTimeout"/>.
            </summary>
            <remarks>Потокобезопасно.</remarks>
            <param name="disconnectTimeout">Максимальное время ожидания завершения выполняющихся запросов.</param>
            <param name="closeDescription">Причина закрытия соединения которая будет передана удалённой стороне.</param>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.BeginShutdown(System.TimeSpan,System.String)">
            <summary>
            Начинает грациозную остановку. Не блокирует поток.
            Результат остановки можно получить через <see cref="P:DanilovSoft.vRPC.VRpcClient.Completion"/>.
            Потокобезопасно.
            </summary>
            <param name="disconnectTimeout">Максимальное время ожидания завершения выполняющихся запросов.</param>
            <param name="closeDescription">Причина закрытия соединения которая будет передана удалённой стороне.</param>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.ShutdownAsync(System.TimeSpan,System.String)">
            <summary>
            Выполняет грациозную остановку. Блокирует выполнение не дольше чем задано в <paramref name="disconnectTimeout"/>.
            Потокобезопасно.
            </summary>
            <param name="disconnectTimeout">Максимальное время ожидания завершения выполняющихся запросов.</param>
            <param name="closeDescription">Причина закрытия соединения которая будет передана удалённой стороне.</param>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.GetOrOpenConnection(DanilovSoft.vRPC.AccessToken)">
            <summary>
            Возвращает существующее подключение или создаёт новое если это разрешает свойство <see cref="P:DanilovSoft.vRPC.VRpcClient.IsAutoConnectAllowed"/>.
            </summary>
            <exception cref="T:DanilovSoft.vRPC.VRpcShutdownException"/>
            <exception cref="T:DanilovSoft.vRPC.VRpcConnectionNotOpenException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.OnClientMethodCall``1(DanilovSoft.vRPC.RequestMethodMeta,System.Object[])">
            <exception cref="T:DanilovSoft.vRPC.VRpcShutdownException"/>
            <exception cref="T:DanilovSoft.vRPC.VRpcConnectionNotOpenException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.OnClientNotificationCall(DanilovSoft.vRPC.RequestMethodMeta,System.Object[])">
            <summary>
            Когда выполняют вызов метода через интерфейс.
            </summary>
            <exception cref="T:DanilovSoft.vRPC.VRpcShutdownException"/>
            <exception cref="T:DanilovSoft.vRPC.VRpcConnectionNotOpenException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.OnDisconnected(System.Object,DanilovSoft.vRPC.SocketDisconnectedEventArgs)">
            <summary>
            Событие — обрыв сокета. Потокобезопасно. Срабатывает только один раз.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.ConnectOrGetExistedConnectionAsync(DanilovSoft.vRPC.AccessToken)">
            <summary>
            Выполнить подключение сокета если еще не подключен.
            </summary>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.LockAquiredConnectAsync(System.Threading.AsyncLock.Releaser,DanilovSoft.vRPC.AccessToken)">
            <exception cref="T:DanilovSoft.vRPC.VRpcShutdownException"/>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.LockAquiredConnectAsync(DanilovSoft.vRPC.AccessToken)">
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.InnerConfigureIoC(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Добавляет в IoC контейнер контроллеры из сборки и компилирует контейнер.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.ThrowIfDisposed">
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.ThrowIfWasShutdown">
            <summary>
            Проверяет установку волатильного свойства <see cref="F:DanilovSoft.vRPC.VRpcClient._shutdownRequest"/>.
            </summary>
            <exception cref="T:DanilovSoft.vRPC.VRpcShutdownException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcClient.TryGetShutdownException``1(System.Threading.Tasks.ValueTask{``0}@)">
            <summary>
            Проверяет установку волатильного свойства <see cref="F:DanilovSoft.vRPC.VRpcClient._shutdownRequest"/>.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.VRpcState.ShutdownRequest">
            <summary>
            Произошел запрос на остановку сервиса – подключать данный экземпляр больше нельзя.
            Причину остановки можно узнать через свойство <see cref="P:DanilovSoft.vRPC.VRpcClient.StopRequiredState"/>.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.ClientSideConnection.SignInAsyncMeta">
            <summary>
            Internal запрос для аутентификации.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.ClientSideConnection._authLock">
            <summary>
            Методы SignIn, SignOut (async) должны выполняться последовательно
            что-бы синхронизироваться со свойством IsAuthenticated.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.ClientSideConnection._isAuthenticated">
            <summary>
            Установка свойства только через блокировку <see cref="F:DanilovSoft.vRPC.ClientSideConnection._authLock"/>.
            Перед чтением этого значения нужно дождаться завершения <see cref="F:DanilovSoft.vRPC.ClientSideConnection._lastAuthTask"/> — этот таск может модифицировать значение минуя захват блокировки.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.ClientSideConnection._lastAuthTask">
            <summary>
            Установка свойства только через блокировку <see cref="F:DanilovSoft.vRPC.ClientSideConnection._authLock"/>.
            Этот таск настроен не провоцировать исключения.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ClientSideConnection.#ctor(DanilovSoft.vRPC.VRpcClient,DanilovSoft.WebSockets.ClientWebSocket,Microsoft.Extensions.DependencyInjection.ServiceProvider,DanilovSoft.vRPC.InvokeActionsDictionary)">
            <summary>
            Принимает открытое соединение Web-Socket.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ClientSideConnection.SignIn(DanilovSoft.vRPC.AccessToken)">
            <summary>
            Выполняет аутентификацию соединения.
            </summary>
            <param name="accessToken">Аутентификационный токен передаваемый серверу.</param>
            <exception cref="T:System.Net.Sockets.SocketException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ClientSideConnection.SignInAsync(DanilovSoft.vRPC.AccessToken)">
            <summary>
            Выполняет аутентификацию соединения.
            </summary>
            <param name="accessToken">Аутентификационный токен передаваемый серверу.</param>
            <exception cref="T:System.Net.Sockets.SocketException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ClientSideConnection.PrivateSignInAsync(DanilovSoft.vRPC.AccessToken)">
            <exception cref="T:System.Net.Sockets.SocketException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ClientSideConnection.SignOut">
            <summary>
            
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ClientSideConnection.SignOutAsync">
            <summary>
            
            </summary>
            <exception cref="T:DanilovSoft.vRPC.VRpcException"/>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ClientSideConnection.PrivateSignOutAsync">
            <exception cref="T:DanilovSoft.vRPC.VRpcException"/>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="P:DanilovSoft.vRPC.IMessageMeta.IsRequest">
            <summary>
            True если сообщение является запросом, иначе 
            сообщение это результат запроса.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.IMessageMeta.IsNotificationRequest">
            <summary>
            Может быть True когда IsRequest тоже является True.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.Context.VErrorResponse.AppendHeader(DanilovSoft.vRPC.ArrayBufferWriter{System.Byte},System.Int32,DanilovSoft.vRPC.StatusCode,System.String)">
            <summary>
            Сериализует хэдер в стрим сообщения.
            </summary>
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.IRequest.CompleteNotification(DanilovSoft.vRPC.VRpcException)">
            <summary>
            Если запрос является нотификацией то завершает его ожидание отправки.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.IRequest.CompleteNotification">
            <summary>
            Если запрос является нотификацией то завершает его ожидание отправки.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.JErrorResponse.Id">
            <summary>
            Идентификатор запроса.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.JErrorResponse.#ctor(System.Nullable{System.Int32},DanilovSoft.vRPC.IActionResult)">
            <summary>
            Конструктор ответа в случае ошибки десериализации запроса.
            </summary>
            <param name="errorResult">Может быть <see cref="T:DanilovSoft.vRPC.IActionResult"/> или произвольный объект пользователя.</param>
        </member>
        <member name="M:DanilovSoft.vRPC.JRequest`1.TrySerialize(DanilovSoft.vRPC.ArrayBufferWriter{System.Byte}@)">
            <summary>
            Сериализация пользовательских данных может спровоцировать исключение 
            <exception cref="T:DanilovSoft.vRPC.VRpcSerializationException"/> которое будет перенаправлено ожидающему потоку.
            </summary>
        </member>
        <member name="T:DanilovSoft.vRPC.ManagedConnection">
            <summary>
            Контекст соединения Web-Сокета. Владеет соединением.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.ManagedConnection._invokeMethods">
            <summary>
            Содержит все доступные для вызова экшены контроллеров.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.ManagedConnection._completionTcs">
            <summary>
            Для Completion.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.ManagedConnection._cts">
            <summary>
            Взводится при обрыве соединения.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.ManagedConnection.CompletionToken">
            <summary>
            Срабатывает когда соединение переходит в закрытое состояние.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.ManagedConnection.DisconnectReason">
            <summary>
            Причина закрытия соединения. Это свойство возвращает <see cref="P:DanilovSoft.vRPC.ManagedConnection.Completion"/>.
            Запись через блокировку <see cref="P:DanilovSoft.vRPC.ManagedConnection.DisconnectEventObj"/>.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.ManagedConnection.Completion">
            <summary>
            Возвращает <see cref="T:System.Threading.Tasks.Task"/> который завершается когда 
            соединение переходит в закрытое состояние.
            Возвращает <see cref="P:DanilovSoft.vRPC.ManagedConnection.DisconnectReason"/>.
            Не мутабельное свойство.
            Не бросает исключения.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.ManagedConnection._ws">
            <summary>
            Подключенный TCP сокет.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.ManagedConnection._pendingRequests">
            <summary>
            Коллекция запросов ожидающие ответ от удалённой стороны.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.ManagedConnection._sendChannel">
            <summary>
            Отправка сообщений должна выполняться только через этот канал.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.ManagedConnection.IsDisposed">
            <summary>
            <see langword="volatile"/>
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.ManagedConnection._shutdownRequest">
            <summary>
            Не Null если происходит остановка сервиса.
            Используется для проверки возможности начать новый запрос.
            Использовать через блокировку <see cref="P:DanilovSoft.vRPC.ManagedConnection.StopRequiredLock"/>.
            </summary>
            <remarks><see langword="volatile"/></remarks>
        </member>
        <member name="P:DanilovSoft.vRPC.ManagedConnection.StopRequiredLock">
            <summary>
            Предотвращает повторный вызов Stop.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.ManagedConnection._activeRequestCount">
            <summary>
            Количество запросов для обработки и количество ответов для отправки.
            Для отслеживания грациозной остановки сервиса.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.ManagedConnection.DisconnectEventObj">
            <summary>
            Подписку на событие Disconnected нужно синхронизировать что-бы подписчики не пропустили момент обрыва.
            </summary>
        </member>
        <member name="E:DanilovSoft.vRPC.ManagedConnection.Disconnected">
            <summary>
            Событие обрыва соединения. Может сработать только один раз.
            Если подписка на событие происходит к уже отключенному сокету то событие сработает сразу же.
            Гарантирует что событие не будет пропущено в какой бы момент не происходила подписка.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.ManagedConnection.IsConnected">
            <summary>
            Если значение – <see langword="false"/>, то можно узнать причину через свойство <see cref="P:DanilovSoft.vRPC.ManagedConnection.DisconnectReason"/>.
            Когда значение становится <see langword="false"/>, то вызывается событие <see cref="E:DanilovSoft.vRPC.ManagedConnection.Disconnected"/>.
            После разъединения текущий экземпляр не может быть переподключен.
            </summary>
            <remarks><see langword="volatile"/>.</remarks>
        </member>
        <member name="F:DanilovSoft.vRPC.ManagedConnection._reusableJNotification">
            <summary>
            Потоки могут арендровать этот экземпляр, по очереди.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.#ctor(DanilovSoft.WebSockets.ManagedWebSocket,System.Boolean,Microsoft.Extensions.DependencyInjection.ServiceProvider,DanilovSoft.vRPC.InvokeActionsDictionary)">
            <summary>
            Принимает открытое соединение Web-Socket.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.StartReceiveLoopThreads">
            <summary>
            Запускает бесконечный цикл обработки запросов.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.Shutdown(System.TimeSpan,System.String)">
            <summary>
            Выполняет грациозную остановку. Блокирует выполнение не дольше чем задано в <paramref name="disconnectTimeout"/>.
            Потокобезопасно.
            </summary>
            <param name="disconnectTimeout">Максимальное время ожидания завершения выполняющихся запросов.</param>
            <param name="closeDescription">Причина закрытия соединения которая будет передана удалённой стороне.</param>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.ShutdownAsync(System.TimeSpan,System.String)">
            <summary>
            Выполняет грациозную остановку. Блокирует выполнение не дольше чем задано в <paramref name="disconnectTimeout"/>.
            Потокобезопасно.
            </summary>
            <param name="disconnectTimeout">Максимальное время ожидания завершения выполняющихся запросов.</param>
            <param name="closeDescription">Причина закрытия соединения которая будет передана удалённой стороне.</param>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.InnerShutdownAsync(DanilovSoft.vRPC.ShutdownRequest)">
            <summary>
            Запрещает отправку новых запросов; Ожидает когда завершатся текущие запросы 
            и отправляет удалённой стороне сообщение о закрытии соединения с ожиданием подтверджения.
            Затем выполняет Dispose и взводит <see cref="P:DanilovSoft.vRPC.ManagedConnection.Completion"/>.
            </summary>
            <remarks>Не бросает исключения. Потокобезопасно.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.TryDisposeOnCloseReceived">
            <summary>
            Устанавливает причину закрытия соединения для текущего экземпляра и закрывает соединение.
            </summary>
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.TryBeginClose(System.String)">
            <summary>
            Отправляет сообщение Close и ожидает ответный Close. Затем закрывает соединение.
            </summary>
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.TryBeginSendCloseBeforeShutdown">
            <summary>
            Отправляет сообщение Close и ожидает ответный Close. Затем закрывает соединение.
            </summary>
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.OnServerNotificationCall(DanilovSoft.vRPC.RequestMethodMeta,System.Object[])">
            <summary>
            Происходит при обращении к проксирующему интерфейсу.
            </summary>
            <remarks>Со стороны сервера.</remarks>
            <exception cref="T:DanilovSoft.vRPC.VRpcShutdownException"/>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.OnServerRequestCall``1(DanilovSoft.vRPC.VRequest{``0})">
            <summary>
            Происходит при обращении к проксирующему интерфейсу.
            </summary>
            <remarks>Со стороны сервера.</remarks>
            <exception cref="T:DanilovSoft.vRPC.VRpcShutdownException"/>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.OnClientRequestCall``1(System.Threading.Tasks.ValueTask{DanilovSoft.vRPC.ClientSideConnection},DanilovSoft.vRPC.RequestMethodMeta,System.Object[])">
            <summary>
            Происходит при обращении к проксирующему интерфейсу.
            </summary>
            <remarks>Со стороны клиента.</remarks>
            <exception cref="T:DanilovSoft.vRPC.VRpcConnectionNotOpenException"/>
            <exception cref="T:System.Exception">Могут быть исключения не инкапсулированные в Task.</exception>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.OnClientNotificationCall(System.Threading.Tasks.ValueTask{DanilovSoft.vRPC.ClientSideConnection},DanilovSoft.vRPC.RequestMethodMeta,System.Object[])">
            <summary>
            Происходит при обращении к проксирующему интерфейсу.
            </summary>
            <remarks>Со стороны клиента.</remarks>
            <exception cref="T:System.Exception">Могут быть исключения не инкапсулированные в Task.</exception>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.SendNotification(DanilovSoft.vRPC.INotification)">
            <summary>
            Отправляет запрос-уведомление через очередь (выполнит отправку текущим потоком если очередь пуста).
            </summary>
            <exception cref="T:DanilovSoft.vRPC.VRpcShutdownException"/>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.TrySendRequest``1(DanilovSoft.vRPC.IResponseAwaiter,System.Threading.Tasks.Task{``0}@)">
            <summary>
            Отправляет запрос и ожидает ответ.
            Передаёт владение объектом <paramref name="request"/> другому потоку.
            </summary>
            <param name="errorTask">Может быть <see cref="T:System.ObjectDisposedException"/></param>
            <remarks>Происходит при обращении к прокси-интерфейсу. Не бросает исключения.</remarks>
            <returns>Таск с результатом от сервера или с исключением.</returns>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.ReceiveLoop">
            <summary>
            Здесь не должно быть глубокого async стека для сохранения высокой производительности.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.DeserializeJsonRpcMessage(System.ReadOnlySpan{System.Byte},DanilovSoft.vRPC.Context.IMessageToSend@)">
            <summary>Разбор полученного сообщения. Сообщение может быть запросом или ответом на запрос.</summary>
            <exception cref="T:System.Text.Json.JsonException"/>
            <returns>False если нужно завершить поток.</returns>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.TryParseJsonArgs(DanilovSoft.vRPC.ControllerMethodMeta,System.Object[],System.Text.Json.Utf8JsonReader,DanilovSoft.vRPC.IActionResult@)">
            <returns>True если параметры успешно десериализованы.</returns>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.TryNonBinaryTypeCloseAndDisposeAsync(DanilovSoft.WebSockets.ValueWebSocketReceiveResult)">
            <summary>При получении Close или сообщения типа Text — отправляет Close и делает Dispose.</summary>
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.TryProcessPayload(DanilovSoft.vRPC.HeaderDto@,System.ReadOnlyMemory{System.Byte})">
            <summary>
            Десериализует Payload и выполняет запрос или передаёт ответ ожидающему потоку.
            </summary>
            <param name="payload">Контент запроса целиком.</param>
            <returns>false если нужно завершить поток чтения.</returns>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.ValidateHeader(DanilovSoft.vRPC.HeaderDto@)">
            <returns>true если хедер валиден.</returns>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.TryIncreaseActiveRequestsCount(System.Boolean)">
            <summary>
            Увеличивает счётчик активных запросов.
            </summary>
            <returns>true если разрешено продолжить выполнение запроса, 
            false если требуется остановить сервис.</returns>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.TryCloseReceivedAsync">
            <summary>Отправляет Close и делает Dispose.</summary>
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.TryFinishSenderAndSendCloseAsync">
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.TrySendNotSupportedTypeAndCloseAsync">
            <summary>
            Отправляет Close и делает Dispose.
            </summary>
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.TryProtocolErrorCloseAsync(System.String)">
            <summary>
            Закрывает WebSocket с кодом 1002: ProtocolError и сообщением <paramref name="message"/>.
            Распространяет исключение <see cref="T:DanilovSoft.vRPC.VRpcProtocolErrorException"/>.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.SendCloseParseErrorAsync(System.Text.Json.JsonException)">
            <summary>
            Отправляет Close с сообщением и распространяет исключение <see cref="T:DanilovSoft.vRPC.VRpcProtocolErrorException"/> ожидающим потокам.
            </summary>
            <remarks>Для Json-RPC</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.TryCompleteSenderAsync">
            <summary>
            Гарантирует что ничего больше не будет отправлено через веб-сокет. 
            Дожидается завершения отправляющего потока.
            Атомарно возвращает true означающее что поток должен выполнить Close.
            </summary>
            <remarks>Не бросает исключения.</remarks>
            <returns>true если текущий поток запрыл канал, false если канал уже был закрыт другим потоком.</returns>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.TryCloseAndDisposeAsync(DanilovSoft.vRPC.VRpcProtocolErrorException,System.String)">
            <summary>
            Отправляет Close если канал ещё не закрыт и выполняет Dispose.
            Распространяет исключение <paramref name="protocolErrorException"/> всем ожидаюшим потокам.
            </summary>
            <remarks>Не бросает исключения.</remarks>
            <param name="protocolErrorException">Распространяет исключение ожидаюшим потокам.</param>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.TryPostMessage(DanilovSoft.vRPC.Context.IMessageToSend)">
            <summary>
            Передает на отправку другому потоку если канал ещё не закрыт.
            </summary>
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.SendLoop">
            <summary>
            Ждёт сообщения через очередь и отправляет в сокет.
            </summary>
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.ActionPermissionCheck(DanilovSoft.vRPC.ControllerMethodMeta,DanilovSoft.vRPC.IActionResult@,System.Security.Claims.ClaimsPrincipal@)">
            <summary>
            Проверяет доступность запрашиваемого метода для удаленного пользователя.
            </summary>
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.TryIncreaseActiveRequestsCount">
            <summary>
            Увеличивает счётчик на 1 при получении запроса или при отправке запроса.
            </summary>
            <returns>False если был запрошен Shutdown и сервис нужно остановить.</returns>
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.DecreaseActiveRequestsCountOrClose">
            <summary>
            Уменьшает счётчик после отправки ответа на запрос.
            </summary>
            <returns>False если сервис требуется остановить.</returns>
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.TryDecreaseActiveRequestsCount">
            <summary>
            Безусловно уменьшает счётчик активных запросов на 1.
            </summary>
            <returns>False если был запрошен Shutdown и сервис нужно остановить.</returns>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.CreateRequestContextAndStart(System.Nullable{System.Int32},DanilovSoft.vRPC.ControllerMethodMeta,System.Object[],System.Boolean)">
            <summary>
            
            </summary>
            <param name="id">Может быть Null если нотификация.</param>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.OnStartProcessRequest(DanilovSoft.vRPC.RequestContext)">
            <summary>
            Выполняет запрос и отправляет результат или ошибку.
            </summary>
            <remarks>Точка входа потока из пула.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.InvokeControllerAsync(DanilovSoft.vRPC.RequestContext)">
            <summary>
            Вызывает запрошенный метод контроллера и возвращает результат.
            Результатом может быть IActionResult или Raw объект или исключение.
            </summary>
            <exception cref="T:System.Exception">Исключение пользователя.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
            <param name="requestContext">Гарантированно выполнит Dispose.</param>
            <returns><see cref="T:DanilovSoft.vRPC.IActionResult"/> или любой объект.</returns>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.ProcessNotificationRequest(DanilovSoft.vRPC.RequestContext)">
            <summary>
            
            </summary>
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.SendOkResponse(DanilovSoft.vRPC.RequestContext)">
            <exception cref="T:System.Exception">Ошибка сериализации пользовательских данных.</exception>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.SendInternalErrorResponse(DanilovSoft.vRPC.RequestContext,System.String)">
            <summary>
            Отправляет ответ как "Internal error".
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.TryDispose(DanilovSoft.vRPC.CloseReason)">
            <summary>
            Потокобезопасно освобождает ресурсы соединения. Вызывается при закрытии соединения.
            Взводит <see cref="P:DanilovSoft.vRPC.ManagedConnection.Completion"/> и передаёт исключение всем ожидающим запросам.
            </summary>
            <remarks>Не бросает исключения.</remarks>
            <param name="possibleReason">Одна из возможных причин обрыва соединения.</param>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.TrySetCompletion(DanilovSoft.vRPC.CloseReason)">
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.ManagedConnection.Dispose">
            <summary>
            Потокобезопасно закрывает соединение и освобождает все ресурсы.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ReusableVNotification.#ctor">
            <summary>
            Для создания синглтона.
            </summary>
        </member>
        <member name="T:DanilovSoft.vRPC.ServerSideConnection">
            <summary>
            Подключенный к серверу клиент.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.ServerSideConnection.User">
            <summary>
            Пользователь ассоциированный с текущим соединением.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.ServerSideConnection.Listener">
            <summary>
            Сервер который принял текущее соединение.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ServerSideConnection.GetProxy``1">
            <summary>
            Создает прокси к методам удалённой стороны на основе интерфейса. Повторное обращение вернет экземпляр из кэша.
            Полученный экземпляр можно привести к типу <see cref="T:DanilovSoft.vRPC.Decorator.ServerInterfaceProxy"/>.
            Метод является шорткатом для <see cref="M:DanilovSoft.vRPC.ServerSideConnection.GetProxyDecorator``1"/>
            </summary>
            <typeparam name="T">Интерфейс.</typeparam>
        </member>
        <member name="M:DanilovSoft.vRPC.ServerSideConnection.GetProxyDecorator``1">
            <summary>
            Создает прокси к методам удалённой стороны на основе интерфейса. Повторное обращение вернет экземпляр из кэша.
            </summary>
            <typeparam name="T">Интерфейс.</typeparam>
        </member>
        <member name="M:DanilovSoft.vRPC.ServerSideConnection.SignIn(DanilovSoft.vRPC.AccessToken)">
            <summary>
            Производит аутентификацию текущего подключения.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ServerSideConnection.SignOut">
            <summary>
            Сбрасывает аутентификацию соединения в изначальное состояние.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ServerSideConnection.ActionPermissionCheck(DanilovSoft.vRPC.ControllerMethodMeta,DanilovSoft.vRPC.IActionResult@,System.Security.Claims.ClaimsPrincipal@)">
            <summary>
            Проверяет доступность запрашиваемого метода пользователем.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ServerSideConnection.Call(System.String,System.String,System.Object[])">
            <exception cref="T:DanilovSoft.vRPC.VRpcException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ServerSideConnection.CallAsync(System.String,System.String,System.Object[])">
            <exception cref="T:DanilovSoft.vRPC.VRpcException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ServerSideConnection.Call``1(System.String,System.String,System.Object[])">
            <exception cref="T:DanilovSoft.vRPC.VRpcException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ServerSideConnection.CallAsync``1(System.String,System.String,System.Object[])">
            <exception cref="T:DanilovSoft.vRPC.VRpcException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRequest`1.SetException(DanilovSoft.vRPC.VRpcException)">
            <summary>
            Передает ожидающему потоку исключение как результат запроса.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.VRequest`1.SetException(System.Exception)">
            <summary>
            Передает ожидающему потоку исключение как результат запроса.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.VRequest`1.SetVResponse(DanilovSoft.vRPC.HeaderDto@,System.ReadOnlyMemory{System.Byte})">
            <summary>
            Передаёт ответ ожидающему потоку.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.VRequest`1.SetJResponse(System.Text.Json.Utf8JsonReader@)">
            <summary>
            Передаёт ответ ожидающему потоку.
            </summary>
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="P:DanilovSoft.vRPC.ClientController.Context">
            <summary>
            Контекст подключения на стороне клиента.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.ServerController.Context">
            <summary>
            Контекст подключения.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.ServerController.User">
            <summary>
            Пользователь ассоциированный с текущим запросом.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ServerController.CreateAccessToken(System.Security.Claims.ClaimsPrincipal,System.TimeSpan)">
            <exception cref="T:DanilovSoft.vRPC.VRpcException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ServerController.SignOut">
            <summary>
            Сбрасывает аутентификацию соединения в изначальное состояние.
            </summary>
        </member>
        <member name="T:DanilovSoft.vRPC.Decorator.ClientInterfaceProxy">
            <summary>
            Этот клас наследует пользовательские интерфейсы.
            </summary>
        </member>
        <member name="T:DanilovSoft.vRPC.Decorator.ClientInterfaceProxy`1">
            <summary>
            Этот клас реализует пользовательские интерфейсы.
            </summary>
            <remarks>Тип должен быть публичным и не запечатанным.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.Decorator.ClientInterfaceProxy`1.GetMeta``1(System.Reflection.MethodInfo)">
            <summary>
            
            </summary>
            <typeparam name="TResult">Возвращаемый тип метода.</typeparam>
            <param name="targetMethod"></param>
            <exception cref="T:System.Exception">Могут быть неизвестные исключения.</exception>
        </member>
        <member name="T:DanilovSoft.vRPC.Decorator.ServerInterfaceProxy">
            <summary>
            Этот клас наследует пользовательские интерфейсы.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.Decorator.ServerInterfaceProxy.Connection">
            <summary>
            Никогда не Null.
            </summary>
        </member>
        <member name="T:DanilovSoft.vRPC.Decorator.ServerInterfaceProxy`1">
            <summary>
            Этот клас реализует пользовательские интерфейсы.
            </summary>
            <remarks>Тип должен быть публичным и не запечатанным.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.Decorator.ServerInterfaceProxy`1.GetMeta``1(System.Reflection.MethodInfo)">
            <exception cref="T:System.Exception"/>
        </member>
        <member name="T:DanilovSoft.vRPC.HeaderDto">
            <summary>
            Заголовок запроса или ответа. Бинарный размер — динамический. Сериализуется всегда через ProtoBuf.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.HeaderDto.IsResponseRequired">
            <summary>
            true если задан <see cref="P:DanilovSoft.vRPC.HeaderDto.Id"/>.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.HeaderDto.IsRequest">
            <summary>
            Это заголовок запроса когда статус равен <see cref="F:DanilovSoft.vRPC.StatusCode.Request"/>.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.HeaderDto.PayloadEncoding">
            <summary>
            Формат контента. Может быть <see langword="null"/>, тогда 
            следует использовать формат по умолчанию.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.HeaderDto.MethodName">
            <summary>
            У запроса всегда должно быть имя метода.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.HeaderDto.#ctor(System.Nullable{System.Int32},System.Int32,System.String,System.String)">
            <summary>
            Конструктор запроса.
            </summary>
            <param name="id">Может быть Null если запрос является нотификацией.</param>
        </member>
        <member name="M:DanilovSoft.vRPC.HeaderDto.#ctor(System.Int32,System.Int32,System.String,DanilovSoft.vRPC.StatusCode)">
            <summary>
            Конструктор ответа на запрос.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.HeaderDto.#ctor(System.Nullable{System.Int32},DanilovSoft.vRPC.StatusCode,System.Int32,System.String,System.String)">
            <summary>
            Конструктор сериализатора, для ответа и для запроса.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.HeaderDto.SerializeProtoBuf(DanilovSoft.vRPC.ArrayBufferWriter{System.Byte},System.Int32@)">
            <summary>
            Сериализует заголовок.
            </summary>
            <param name="stream"></param>
            <param name="headerSize"></param>
        </member>
        <member name="M:DanilovSoft.vRPC.HeaderDto.SerializeJson(DanilovSoft.vRPC.ArrayBufferWriter{System.Byte})">
            <summary>
            Сериализует заголовок.
            </summary>
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.HeaderDto.DeserializeProtoBuf(System.Byte[],System.Int32,System.Int32)">
            <returns>Может быть Null если не удалось десериализовать.</returns>
        </member>
        <member name="M:DanilovSoft.vRPC.HeaderDto.ToString">
            <summary>
            Используется только для отладки и логирования.
            </summary>
        </member>
        <member name="T:DanilovSoft.vRPC.StatusCode">
            <summary>
            Код состояния передаваемого сообщения.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.StatusCode.ParseError">
            <summary>
            Invalid JSON was received by the server.
            An error occurred on the server while parsing the JSON text.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.StatusCode.InvalidRequest">
            <summary>
            The JSON sent is not a valid Request object.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.StatusCode.MethodNotFound">
            <summary>
            The method does not exist / is not available.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.StatusCode.InvalidParams">
            <summary>
            Invalid method parameter(s).
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.StatusCode.InternalError">
            <summary>
            Internal JSON-RPC error.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.ClientConnectedEventArgs.Connection">
            <summary>
            Подключенный к серверу клиент.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.ClientDisconnectedEventArgs.CloseReason">
            <summary>
            Причина закрытия соединения.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.ConnectionAuthenticationEventArgs.AuthenticateConnectionToken">
            <summary>
            Токен авторизации который будет передан серверу. Может быть Null.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.SocketDisconnectedEventArgs.DisconnectReason">
            <summary>
            Причина обрыва соединения.
            </summary>
        </member>
        <member name="T:DanilovSoft.vRPC.VRpcConnectionClosedException">
            <summary>
            Исключение которое происходит при грациозном закрытии соединения одной из сторон.
            </summary>
        </member>
        <member name="T:DanilovSoft.vRPC.VRpcConnectionNotOpenException">
            <summary>
            Исключение которое происходит при обращении к закрытому соединению.
            </summary>
        </member>
        <member name="T:DanilovSoft.vRPC.VRpcShutdownException">
            <summary>
            Происходит при обращении к выключенному экземпляру или находящемуся в процессе отключения по запросу пользователя.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.IHostApplicationLifetime.ApplicationStarted">
            <summary>
            Triggered when the application host has fully started.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.IHostApplicationLifetime.ApplicationStopping">
            <summary>
            Triggered when the application host is performing a graceful shutdown. Shutdown will block until this event completes.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.IHostApplicationLifetime.ApplicationStopped">
            <summary>
            Triggered when the application host is performing a graceful shutdown. Shutdown will block until this event completes.
            </summary>
        </member>
        <member name="T:DanilovSoft.vRPC.IProxy`1">
            <summary>
            Служит для инъекции зависимостей. Фактически выполняет GetProxy&lt;<typeparamref name="T"/>&gt;() для текущего подключения.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:DanilovSoft.vRPC.IProxy`1.Proxy">
            <summary>
            Прокси из интерфейса.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.IProxy`1.RemoteControllerName">
            <summary>
            Имя удалённого контроллера с которым связан прокси.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.ProxyFactory`1.Proxy">
            <summary>
            Прозрачный прокси к удалённой стороне.
            </summary>
        </member>
        <member name="T:DanilovSoft.vRPC.ArrayBufferWriter`1">
            <summary>
            Этот класс передаётся через интерфейс поэтому лучше не делать структурой.
            </summary>
        </member>
        <member name="T:DanilovSoft.vRPC.RequestContext">
            <summary>
            Содержит запрос с параметрами полученный от удалённой стороны который необходимо выполнить.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.RequestContext.IsResponseRequired">
            <summary>
            Когда Id не Null.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.RequestContext.Method">
            <summary>
            Запрашиваемый метод контроллера.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.RequestContext.Args">
            <summary>
            Аргументы для вызываемого метода.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.RequestContext.IsJsonRpcRequest">
            <summary>
            Если запрос получен в формате JSON-RPC, то и ответ должен быть в формате JSON-RPC.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.RequestContext.SerializeResponseAsVrpc(System.Int32@)">
            <summary>
            Сериализует сообщение в память. Может бросить исключение сериализации.
            </summary>
            <exception cref="T:System.Text.Json.JsonException">Ошибка сериализации пользовательских данных.</exception>
            <exception cref="T:ProtoBuf.ProtoException">Ошибка сериализации пользовательских данных.</exception>
        </member>
        <member name="M:DanilovSoft.vRPC.RequestContext.AppendHeader(DanilovSoft.vRPC.ArrayBufferWriter{System.Byte},System.Int32,DanilovSoft.vRPC.StatusCode,System.String)">
            <summary>
            Сериализует хэдер в стрим сообщения.
            </summary>
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.RequestContext.StartProcessRequest">
            <summary>
            В новом потоке выполняет запрос и отправляет обратно результат или ошибку.
            </summary>
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="T:DanilovSoft.vRPC.RequestMethodMeta">
            <summary>
            Описывает метод который требуется вызвать на удалённой стороне.
            Не подлежит сериализации.
            Потокобезопасен.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.RequestMethodMeta.ReturnType">
            <summary>
            Инкапсулированный в Task тип результата функции. Может быть <see cref="T:DanilovSoft.vRPC.VoidStruct"/> символизирующий тип void.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.RequestMethodMeta.IsNotificationRequest">
            <summary>
            True если метод интерфейса был помечен атрибутом <see cref="T:DanilovSoft.vRPC.NotificationAttribute"/> 
            и соответственно не возвращает результат.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.RequestMethodMeta.FullName">
            <summary>
            Имя метода например 'Home/Hello' без постфикса 'Async'.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.RequestMethodMeta.#ctor(System.Reflection.MethodInfo,System.Type,System.String)">
            <exception cref="T:DanilovSoft.vRPC.VRpcException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.RequestMethodMeta.IsAllParametersIsSpecialType(System.Reflection.MethodInfo)">
            <exception cref="T:DanilovSoft.vRPC.VRpcException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.RequestMethodMeta.#ctor(System.String,System.String,System.Type,System.Boolean)">
            <exception cref="T:DanilovSoft.vRPC.VRpcException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.RequestMethodMeta.ValidateNotification(System.String)">
            <exception cref="T:DanilovSoft.vRPC.VRpcException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.Resources.SR2.GetString(System.String,System.Object)">
            <summary>
            Форматирует строку.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.Resources.SR2.GetString(System.String,System.Object[])">
            <summary>
            Форматирует строку.
            </summary>
            <param name="message"></param>
            <param name="args"></param>
        </member>
        <member name="T:DanilovSoft.vRPC.Resources.SR">
            <summary>
              Класс ресурса со строгой типизацией для поиска локализованных строк и т.д.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.Resources.SR.ResourceManager">
            <summary>
              Возвращает кэшированный экземпляр ResourceManager, использованный этим классом.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.Resources.SR.Culture">
            <summary>
              Перезаписывает свойство CurrentUICulture текущего потока для всех
              обращений к ресурсу с помощью этого класса ресурса со строгой типизацией.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.Resources.SR.CloseAsyncProtocolError">
            <summary>
              Ищет локализованную строку, похожую на An error has occurred during header deserialization: {0}.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.Resources.SR.JsonRpcProtocolError">
            <summary>
              Ищет локализованную строку, похожую на An error has occurred during json deserialization from the remote side and connection will be closed. Error: {0}.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.Resources.SR.ProtocolError">
            <summary>
              Ищет локализованную строку, похожую на An error has occurred during header deserialization from the remote side and connection will be closed. Error: {0}.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.Resources.SR.SenderLoopError">
            <summary>
              Ищет локализованную строку, похожую на Ошибка в потоке отправляющем сообщения..
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.Resources.SR.TextMessageTypeNotSupported">
            <summary>
              Ищет локализованную строку, похожую на WebSocket messages type should be Binary but we&apos;ve got Text.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.VRpcListener._applicationStarted">
            <summary>
            Triggered when the application host has fully started.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.VRpcListener._applicationStopping">
            <summary>
            Triggered when the application host is performing a graceful shutdown. Shutdown will block until this event completes.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.VRpcListener._applicationStopped">
            <summary>
            Triggered when the application host is performing a graceful shutdown. Shutdown will block until this event completes.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.VRpcListener.InvokeActions">
            <summary>
            Словарь используемый только для чтения, поэтому потокобезопасен.
            Хранит все доступные контроллеры. Не учитывает регистр.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.VRpcListener._connections">
            <summary>
            Доступ через блокировку SyncObj.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.VRpcListener.StartLock">
            <summary>
            Для доступа к <see cref="F:DanilovSoft.vRPC.VRpcListener._stopRequired"/> и <see cref="F:DanilovSoft.vRPC.VRpcListener._started"/>.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.VRpcListener.Completion">
            <summary>
            <see cref="T:System.Threading.Tasks.Task"/> который завершается когда все 
            соединения перешли в закрытое состояние и сервис полностью остановлен.
            Не бросает исключения.
            Возвращает <see langword="true"/> если остановка прошла грациозно.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.VRpcListener._started">
            <summary>
            Единожны меняет состояние на <see langword="true"/>.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.VRpcListener.ServiceProvider">
            <summary>
            Может быть <see langword="null"/> если не выполнен ConfigureService и сервис ещё не запущен.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.VRpcListener._stopRequired">
            <summary>
            Не позволяет подключаться новым клиентам. Единожны меняет состояние в момент остановки сервиса.
            Также предотвращает повторный запуск сервиса.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcListener.ConfigureService(System.Action{Microsoft.Extensions.DependencyInjection.ServiceCollection})">
            <summary>
            Позволяет настроить IoC контейнер.
            Выполняется единожды при инициализации подключения.
            </summary>
            <param name="configure"></param>
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcListener.Configure(System.Action{Microsoft.Extensions.DependencyInjection.ServiceProvider})">
            <exception cref="T:DanilovSoft.vRPC.VRpcException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcListener.Shutdown(System.TimeSpan,System.String)">
            <summary>
            Выполняет грациозную остановку сервиса. Блокирует поток не дольше чем задано в <paramref name="disconnectTimeout"/>.
            Потокобезопасно.
            </summary>
            <param name="disconnectTimeout">Максимальное время ожидания завершения выполняющихся запросов.</param>
            <param name="closeDescription">Причина закрытия соединения которая будет передана удалённой стороне.</param>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcListener.BeginShutdown(System.TimeSpan,System.String)">
            <summary>
            Начинает остановку сервиса. Не блокирует поток.
            Не бросает исключения.
            Результат остановки можно получить через <see cref="P:DanilovSoft.vRPC.VRpcListener.Completion"/>.
            </summary>
            <param name="disconnectTimeout">Максимальное время ожидания завершения выполняющихся запросов.</param>
            <param name="closeDescription">Причина закрытия соединения которая будет передана удалённой стороне.
            Может быть <see langword="null"/>.</param>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcListener.ShutdownAsync(System.TimeSpan,System.String)">
            <summary>
            Останавливает сервис и ожидает до полной остановки.
            Не бросает исключения.
            Эквивалентно <see cref="M:DanilovSoft.vRPC.VRpcListener.BeginShutdown(System.TimeSpan,System.String)"/> + <see langword="await"/> <see cref="P:DanilovSoft.vRPC.VRpcListener.Completion"/>.
            </summary>
            <param name="disconnectTimeout">Максимальное время ожидания завершения выполняющихся запросов.</param>
            <param name="closeDescription">Причина остановки сервиса которая будет передана удалённой стороне.
            Может быть <see langword="null"/>.</param>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcListener.InnerBeginShutdown(System.TimeSpan,System.String)">
            <summary>
            Начинает остановку сервера и взводит <see cref="P:DanilovSoft.vRPC.VRpcListener.Completion"/> не дольше чем указано в <paramref name="disconnectTimeout"/>.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcListener.RunAsync">
            <summary>
            Начинает приём подключений и обработку запросов до полной остановки методом Stop.
            Эквивалентно вызову метода Start с дальнейшим <see langword="await"/> Completion.
            Повторный вызов не допускается.
            Потокобезопасно.
            </summary>
            <exception cref="T:DanilovSoft.vRPC.VRpcException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcListener.RunAsync(System.TimeSpan,System.String,System.Threading.CancellationToken)">
            <summary>
            Начинает приём подключений и обработку запросов до полной остановки методом Stop
            или с помощью токена отмены.
            Эквивалентно вызову метода Start с дальнейшим <see langword="await"/> Completion.
            Повторный вызов не допускается.
            Потокобезопасно.
            </summary>
            <param name="disconnectTimeout">Максимальное время ожидания завершения выполняющихся запросов когда произойдёт остановка сервиса.</param>
            <param name="closeDescription">Причина остановки сервиса которая будет передана удалённой стороне.
            Может быть <see langword="null"/>.</param>
            <param name="cancellationToken">Токен служащий для остановки сервиса.</param>
            <exception cref="T:DanilovSoft.vRPC.VRpcException"/>
            <exception cref="T:System.OperationCanceledException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcListener.InnerRunAsync(System.TimeSpan,System.String,System.Threading.CancellationToken)">
            <exception cref="T:System.OperationCanceledException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcListener.Start">
            <summary>
            Начинает приём новых подключений.
            Повторный вызов спровоцирует исключение.
            Потокобезопасно.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcListener.TrySyncStart(System.Boolean)">
            <summary>
            Потокобезопасно запускает сервер. Только первый поток получит True.
            </summary>
            <exception cref="T:DanilovSoft.vRPC.VRpcException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcListener.InnerTryStart(System.Boolean)">
            <summary>
            Предотвращает повторный запуск сервера.
            </summary>
            <exception cref="T:DanilovSoft.vRPC.VRpcException"/>
            <exception cref="T:DanilovSoft.vRPC.VRpcShutdownException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcListener.GetConnections">
            <summary>
            Возвращает копию коллекции подключенных клиентов.
            Потокобезопасно.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.VRpcListener.GetConnectionsExcept(DanilovSoft.vRPC.ServerSideConnection)">
            <summary>
            Возвращает копию коллекции подключенных клиентов кроме <paramref name="exceptCon"/>.
            Потокобезопасно.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.ClientConnections.SyncObj">
            <summary>
            Модификация коллекции <see cref="F:DanilovSoft.vRPC.VRpcListener._connections"/> допускается с захватом этой блокировки.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.CloseReason.NoConnectionGracifully">
            <summary>
            "Соединение не установлено."
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.CloseReason.Gracifully">
            <summary>
            Является <see langword="true"/> если разъединение завершилось грациозно.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.CloseReason.ConnectionError">
            <summary>
            Является <see langword="null"/> если разъединение завершилось грациозно
            и не является <see langword="null"/> когда разъединение завершилось не грациозно.
            </summary>
            <remarks>Может быть производными типа <see cref="T:DanilovSoft.vRPC.VRpcException"/> или <see cref="T:System.ObjectDisposedException"/></remarks>
        </member>
        <member name="P:DanilovSoft.vRPC.CloseReason.CloseDescription">
            <summary>
            Сообщение от удалённой стороны указывающее причину разъединения (может быть <see langword="null"/>).
            Если текст совпадает с переданным в метод Shutdown то разъединение произошло по вашей инициативе.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.CloseReason.AdditionalDescription">
            <summary>
            Может быть <see langword="null"/>. Не зависит от <see cref="P:DanilovSoft.vRPC.CloseReason.Gracifully"/>.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.CloseReason.ShutdownRequest">
            <summary>
            Если был выполнен запрос на остановку сервиса то это свойство будет не <see langword="null"/>.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.CloseReason.FromException(DanilovSoft.vRPC.VRpcException,DanilovSoft.vRPC.ShutdownRequest,System.String)">
            <summary>
            Создаёт причину обрыва соединения из-за исключения.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.ConnectionState.SocketError">
            <summary>
            Не удалось установить соединение.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.ConnectionState.ShutdownRequest">
            <summary>
            Во время подключения произошел запрос на остановку сервиса – использовать данный экземпляр больше нельзя.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.ConnectionState.Connected">
            <summary>
            Соединение успешно установлено.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.ConnectResult.SocketError">
            <summary>
            Может быть <see cref="F:System.Net.Sockets.SocketError.Success"/> несмотря на то что State == <see cref="F:DanilovSoft.vRPC.ConnectionState.SocketError"/>.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.ConnectResult.ShutdownRequest">
            <summary>
            Не Null если State = <see cref="F:DanilovSoft.vRPC.ConnectionState.ShutdownRequest"/>.
            </summary>
        </member>
        <member name="T:DanilovSoft.vRPC.ControllerMethodMeta">
            <summary>
            Содержит исчерпывающую информацию о методе контроллера.
            Этот клас переиспользуется.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.ControllerMethodMeta.ProducesEncoding">
            <summary>
            Формат возвращаемых данных.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.ControllerMethodMeta.ControllerType">
            <summary>
            Контроллер для активации через IoC.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.CustomVSerializer.TryDeserializeArgs(System.ReadOnlyMemory{System.Byte},DanilovSoft.vRPC.ControllerMethodMeta,DanilovSoft.vRPC.HeaderDto@,System.Object[]@,DanilovSoft.vRPC.IActionResult@)">
            <param name="requestContext">Не Null когда True.</param>
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.CustomVSerializer.TryDeserializeRequestJson(System.ReadOnlySpan{System.Byte},DanilovSoft.vRPC.ControllerMethodMeta,System.Object[]@,DanilovSoft.vRPC.IActionResult@)">
            <summary>
            Десериализует json запрос.
            </summary>
            <exception cref="T:System.Text.Json.JsonException"/>
            <returns>True если успешно десериализовали.</returns>
        </member>
        <member name="M:DanilovSoft.vRPC.CustomVSerializer.DeserializeHeader(System.ReadOnlySpan{System.Byte})">
            <summary>
            Десериализует json запрос.
            </summary>
            <exception cref="T:System.Text.Json.JsonException"/>
            <returns>True если успешно десериализовали.</returns>
        </member>
        <member name="M:DanilovSoft.vRPC.DynamicAwaiter.ConvertToTask(System.Object)">
            <summary>
            Асинхронно ожидает завершение задачи если <paramref name="actionResult"/> является <see cref="T:System.Threading.Tasks.Task"/>'ом.
            </summary>
            <exception cref="T:System.Exception">Инкапсулированное в Task.</exception>
            <param name="actionResult"><see cref="T:System.Threading.Tasks.Task"/> или любой объект.</param>
        </member>
        <member name="M:DanilovSoft.vRPC.Source.ExceptionHelper.ToException(DanilovSoft.vRPC.StatusCode,System.String)">
            <returns>
            <list type="bullet">
            <item><see cref="T:DanilovSoft.vRPC.VRpcMethodNotFoundException"/></item>
            <item><see cref="T:DanilovSoft.vRPC.VRpcInvalidParamsException"/></item>
            <item><see cref="T:DanilovSoft.vRPC.VRpcUnknownErrorException"/></item>
            </list>
            </returns>
        </member>
        <member name="M:DanilovSoft.vRPC.ExtensionMethods.SerializeRequestArgsJson(DanilovSoft.vRPC.ArrayBufferWriter{System.Byte},System.Object[])">
            <summary>
            Сериализует объект в JSON.
            </summary>
            <exception cref="T:System.Text.Json.JsonException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ExtensionMethods.SerializeResponseJson(DanilovSoft.vRPC.ArrayBufferWriter{System.Byte},System.Object)">
            <summary>
            Сериализует объект в JSON.
            </summary>
            <exception cref="T:System.Text.Json.JsonException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ExtensionMethods.SerializeObjectJson``1(System.IO.Stream,``0)">
            <summary>
            Сериализует объект в JSON.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ExtensionMethods.DeserializeJson(System.ReadOnlySpan{System.Byte},System.Type)">
            <summary>
            Десериализует Json.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ExtensionMethods.DeserializeJson(System.ReadOnlyMemory{System.Byte},System.Type)">
            <summary>
            Десериализует Json.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ExtensionMethods.DeserializeJson``1(System.ReadOnlySpan{System.Byte})">
            <summary>
            Десериализует Json.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ExtensionMethods.ReadAsString(System.IO.Stream)">
            <summary>
            Читает строку в формате Utf-8.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ExtensionMethods.ReadAsString(System.Memory{System.Byte})">
            <summary>
            Читает строку в формате Utf-8.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ExtensionMethods.ReadAsString(System.ReadOnlyMemory{System.Byte})">
            <summary>
            Читает строку в формате Utf-8.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ExtensionMethods.WriteStringBinary(System.Buffers.IBufferWriter{System.Byte},System.String)">
            <summary>
            Записывает строку в формате Utf-8.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ExtensionMethods.IsAsyncMethod(System.Reflection.MethodInfo)">
            <summary>
            Возвращает <see langword="true"/> если функция имеет возвращаемый тип <see cref="T:System.Threading.Tasks.Task"/> или <see cref="T:System.Threading.Tasks.Task`1"/>
            или <see cref="T:System.Threading.Tasks.ValueTask"/> или <see cref="T:System.Threading.Tasks.ValueTask`1"/>.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ExtensionMethods.IsAsyncReturnType(System.Type)">
            <summary>
            Возвращает <see langword="true"/> если тип является <see cref="T:System.Threading.Tasks.Task"/> или <see cref="T:System.Threading.Tasks.Task`1"/>
            или <see cref="T:System.Threading.Tasks.ValueTask"/> или <see cref="T:System.Threading.Tasks.ValueTask`1"/>.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ExtensionMethods.GetNameTrimAsync(System.Reflection.MethodInfo)">
            <summary>
            Нормализует имя функции если она является Task-Async.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ExtensionMethods.ToException(DanilovSoft.vRPC.CloseReason)">
            <remarks>Может быть производными типа <see cref="T:DanilovSoft.vRPC.VRpcException"/> или <see cref="T:System.ObjectDisposedException"/></remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.ExtensionMethods.GetMessageFromCloseFrame(System.Nullable{System.Net.WebSockets.WebSocketCloseStatus},System.String)">
            <summary>
            Формирует сообщение ошибки из фрейма веб-сокета информирующем о закрытии соединения. Пустую строку не возвращает.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ExtensionMethods.ToPublicConnectResult(DanilovSoft.vRPC.InnerConnectionResult@)">
            <summary>
            Не бросает исключения.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.GlobalVars.FindAllControllers(System.Reflection.Assembly)">
            <exception cref="T:DanilovSoft.vRPC.VRpcException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.InnerConnectionResult.#ctor(System.Net.Sockets.SocketError)">
            <summary>
            Подключение не удалось (SocketError может быть Success).
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.InnerConnectionResult.FromShutdownRequest(DanilovSoft.vRPC.ShutdownRequest)">
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.InnerConnectionResult.ToManagedConnection">
            <summary>
            Может бросить исключение.
            </summary>
            <exception cref="T:DanilovSoft.vRPC.VRpcSocketException"/>
            <exception cref="T:DanilovSoft.vRPC.VRpcShutdownException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.InnerConnectionResult.ToManagedConnectionTask">
            <summary>
            Может бросить исключение.
            </summary>
            <exception cref="T:DanilovSoft.vRPC.VRpcSocketException"/>
            <exception cref="T:DanilovSoft.vRPC.VRpcShutdownException"/>
        </member>
        <member name="F:DanilovSoft.vRPC.InvokeActionsDictionary._actionsDict">
            <summary>
            Словарь используемый только для чтения.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.JsonRpcSerializer.SerializeRequest(DanilovSoft.vRPC.ArrayBufferWriter{System.Byte},System.String,System.Object[],System.Nullable{System.Int32})">
            <exception cref="T:System.Text.Json.JsonException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.JsonRpcSerializer.TrySerializeRequest(System.String,System.Object[],System.Int32,DanilovSoft.vRPC.ArrayBufferWriter{System.Byte},DanilovSoft.vRPC.VRpcSerializationException@)">
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.JsonRpcSerializer.TrySerializeRequest(System.String,System.Object[],System.Int32,DanilovSoft.vRPC.ArrayBufferWriter{System.Byte}@,DanilovSoft.vRPC.VRpcSerializationException@)">
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.JsonRpcSerializer.SerializeResponse(DanilovSoft.vRPC.ArrayBufferWriter{System.Byte},System.Int32,System.Object)">
            <exception cref="T:System.Text.Json.JsonException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.JsonRpcSerializer.TrySerializeErrorResponse(System.Nullable{System.Int32},DanilovSoft.vRPC.StatusCode,System.String,DanilovSoft.vRPC.ArrayBufferWriter{System.Byte}@,DanilovSoft.vRPC.VRpcSerializationException@)">
            <remarks>Не бросает исключения.</remarks>
        </member>
        <member name="M:DanilovSoft.vRPC.JsonRpcSerializer.SerializeErrorResponse(DanilovSoft.vRPC.ArrayBufferWriter{System.Byte},DanilovSoft.vRPC.StatusCode,System.String,System.Nullable{System.Int32})">
            <exception cref="T:System.Text.Json.JsonException"/>
        </member>
        <member name="T:DanilovSoft.vRPC.LockedDictionary`2">
            <summary>
            Использует блокировку для GetOrAdd.
            </summary>
        </member>
        <member name="T:DanilovSoft.vRPC.PendingRequestDictionary">
            <summary>
            Потокобезопасная очередь запросов к удалённой стороне ожидающих ответы.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.PendingRequestDictionary._spinWait">
            <summary>
            Не является потокобезопасным.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.PendingRequestDictionary._disconnectException">
            <summary>
            Может быть производным типом <see cref="T:DanilovSoft.vRPC.VRpcException"/> или <see cref="T:System.ObjectDisposedException"/>.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.PendingRequestDictionary.#ctor">
            <summary>
            Потокобезопасная очередь запросов к удалённой стороне ожидающих ответы.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.PendingRequestDictionary.Add(DanilovSoft.vRPC.IResponseAwaiter,System.Int32@)">
            <summary>
            Потокобезопасно добавляет запрос в словарь запросов и возвращает уникальный идентификатор.
            </summary>
            <exception cref="T:DanilovSoft.vRPC.VRpcException">Происходит если уже был обрыв соединения.</exception>
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.PendingRequestDictionary.TryRemove(System.Int32,DanilovSoft.vRPC.IResponseAwaiter@)">
            <summary>
            Потокобезопасно удаляет запрос из словаря.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.PendingRequestDictionary.TryPropagateExceptionAndLockup(System.Exception)">
            <summary>
            Распространяет исключение всем ожидающим запросам. Дальнейшее создание запросов будет провоцировать это исключение.
            </summary>
            <remarks>Не бросает исключения. Потокобезопасно.</remarks>
        </member>
        <member name="F:DanilovSoft.vRPC.ProxyCache._staticDict">
            <summary>
            Содержит прокси созданные из интерфейсов.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.ProxyCache._instanceDict">
            <summary>
            Содержит прокси созданные из интерфейсов.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.IResponseAwaiter.SetException(DanilovSoft.vRPC.VRpcException)">
            <summary>
            Передает ожидающему потоку исключение как результат запроса.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.IResponseAwaiter.SetException(System.Exception)">
            <summary>
            Передает ожидающему потоку исключение как результат запроса.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.IResponseAwaiter.SetVResponse(DanilovSoft.vRPC.HeaderDto@,System.ReadOnlyMemory{System.Byte})">
            <summary>
            Передаёт ответ ожидающему потоку.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.IResponseAwaiter.SetJResponse(System.Text.Json.Utf8JsonReader@)">
            <summary>
            Передаёт ответ ожидающему потоку.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.ShutdownRequest.CloseDescription">
            <summary>
            Причина остановки сервиса указанная пользователем. Может быть <see langword="null"/>.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.ShutdownRequest.ShutdownTimeout">
            <summary>
            Максимальное время ожидания остановки сервиса указанное пользователем 
            после которого все соединения закрываются принудительно.
            </summary>
        </member>
        <member name="T:DanilovSoft.vRPC.ThrowHelper">
            <summary>
            Для оптимизации горячих путей. Потому что JIT не встраивает методы в которых есть throw.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.ThrowHelper.ThrowConnectException(System.String,System.Exception)">
            <exception cref="T:DanilovSoft.vRPC.VRpcConnectException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ThrowHelper.ThrowObjectDisposedException(System.String)">
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ThrowHelper.ThrowObjectDisposedException(System.String,System.String)">
            <exception cref="T:System.ObjectDisposedException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ThrowHelper.ThrowWasShutdownException(DanilovSoft.vRPC.ShutdownRequest)">
            <exception cref="T:DanilovSoft.vRPC.VRpcShutdownException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ThrowHelper.ThrowArgumentNullException(System.String)">
            <exception cref="T:System.ArgumentNullException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ThrowHelper.ThrowVRpcException(System.String)">
            <exception cref="T:DanilovSoft.vRPC.VRpcException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ThrowHelper.ThrowVRpcException(System.String,System.Exception)">
            <exception cref="T:DanilovSoft.vRPC.VRpcException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ThrowHelper.ThrowArgumentOutOfRangeException(System.String)">
            <exception cref="T:System.ArgumentOutOfRangeException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ThrowHelper.ThrowArgumentException(System.String)">
            <exception cref="T:System.ArgumentException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ThrowHelper.ThrowArgumentOutOfRangeException(System.String,System.String)">
            <exception cref="T:System.ArgumentOutOfRangeException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ThrowHelper.ThrowInvalidOperationException(System.String)">
            <exception cref="T:System.InvalidOperationException"/>
        </member>
        <member name="M:DanilovSoft.vRPC.ThrowHelper.ThrowNotSupportedException(System.String)">
            <exception cref="T:System.NotSupportedException"/>
        </member>
        <member name="T:DanilovSoft.vRPC.UserConnectionCollection">
            <summary>
            Потокобезопасный список авторизованных соединений пользователя.
            </summary>
        </member>
        <member name="F:DanilovSoft.vRPC.UserConnectionCollection._list">
            <summary>
            Доступ осуществляется только через блокировку <see cref="F:DanilovSoft.vRPC.UserConnectionCollection.SyncRoot"/>.
            </summary>
        </member>
        <member name="P:DanilovSoft.vRPC.UserConnectionCollection.IsDestroyed">
            <summary>
            Доступ осуществляется только через блокировку <see cref="F:DanilovSoft.vRPC.UserConnectionCollection.SyncRoot"/>.
            Если коллекция уже была удалена из словаря подключений, то значение будет <see langword="true"/> 
            и испольльзовать этот экземпляр больше нельзя.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.UserConnectionCollection.GetEnumerator">
            <summary>
            Возвращает копию своей коллекции.
            </summary>
        </member>
        <member name="M:DanilovSoft.vRPC.Warmup.DoWarmup">
            <summary>
            Выполняет AOT(Ahead-Of-Time) оптимизацию.
            </summary>
        </member>
        <member name="M:DynamicMethodsLib.ILGeneratorExtensions.PushInstance(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>
            Ldarg_0.
            </summary>
        </member>
        <member name="M:DynamicMethodsLib.ILGeneratorExtensions.Emit_Ldarg(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>
            Загружает аргумент с индексом <paramref name="argIndex"/> в стек вычислений.
            </summary>
        </member>
        <member name="M:DynamicMethodsLib.ILGeneratorExtensions.Emit_Ldc_I4(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>
            Помещает целочисленное значение <paramref name="n"/> в стек вычислений как <see langword="int32"/>.
            </summary>
        </member>
        <member name="M:DynamicMethodsLib.ProxyBuilder`1.CreateProxy``1(`0,System.Object)">
            <summary>
            
            </summary>
            <typeparam name="TIface"></typeparam>
            <param name="source"></param>
            <param name="instance">Параметр который будет передан в конструктор <typeparamref name="TClass"/></param>
            <exception cref="T:DanilovSoft.vRPC.VRpcException"/>
        </member>
        <member name="T:System.IO.ReadOnlyMemoryStream">
            <summary>Provides a <see cref="T:System.IO.Stream"/> for the contents of a <see cref="T:System.ReadOnlyMemory`1"/>.</summary>
        </member>
        <member name="T:System.IO.StreamHelpers">
            <summary>Provides methods to help in the implementation of Stream-derived types.</summary>
        </member>
        <member name="M:System.IO.StreamHelpers.ValidateCopyToArgs(System.IO.Stream,System.IO.Stream,System.Int32)">
            <summary>Validate the arguments to CopyTo, as would Stream.CopyTo.</summary>
        </member>
        <member name="T:System.Threading.Tasks.TaskToApm">
            <summary>
            Provides support for efficiently using Tasks to implement the APM (Begin/End) pattern.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskToApm.Begin(System.Threading.Tasks.Task,System.AsyncCallback,System.Object)">
            <summary>
            Marshals the Task as an IAsyncResult, using the supplied callback and state
            to implement the APM pattern.
            </summary>
            <param name="task">The Task to be marshaled.</param>
            <param name="callback">The callback to be invoked upon completion.</param>
            <param name="state">The state to be stored in the IAsyncResult.</param>
            <returns>An IAsyncResult to represent the task's asynchronous operation.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskToApm.End(System.IAsyncResult)">
            <summary>Processes an IAsyncResult returned by Begin.</summary>
            <param name="asyncResult">The IAsyncResult to unwrap.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskToApm.End``1(System.IAsyncResult)">
            <summary>Processes an IAsyncResult returned by Begin.</summary>
            <param name="asyncResult">The IAsyncResult to unwrap.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskToApm.ThrowArgumentException(System.IAsyncResult)">
            <summary>Throws an argument exception for the invalid <paramref name="asyncResult"/>.</summary>
        </member>
        <member name="T:System.Threading.Tasks.TaskToApm.TaskAsyncResult">
            <summary>Provides a simple IAsyncResult that wraps a Task.</summary>
            <remarks>
            We could use the Task as the IAsyncResult if the Task's AsyncState is the same as the object state,
            but that's very rare, in particular in a situation where someone cares about allocation, and always
            using TaskAsyncResult simplifies things and enables additional optimizations.
            </remarks>
        </member>
        <member name="F:System.Threading.Tasks.TaskToApm.TaskAsyncResult._task">
            <summary>The wrapped Task.</summary>
        </member>
        <member name="F:System.Threading.Tasks.TaskToApm.TaskAsyncResult._callback">
            <summary>Callback to invoke when the wrapped task completes.</summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskToApm.TaskAsyncResult.#ctor(System.Threading.Tasks.Task,System.Object,System.AsyncCallback)">
            <summary>Initializes the IAsyncResult with the Task to wrap and the associated object state.</summary>
            <param name="task">The Task to wrap.</param>
            <param name="state">The new AsyncState value.</param>
            <param name="callback">Callback to invoke when the wrapped task completes.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskToApm.TaskAsyncResult.InvokeCallback">
            <summary>Invokes the callback.</summary>
        </member>
        <member name="P:System.Threading.Tasks.TaskToApm.TaskAsyncResult.AsyncState">
            <summary>Gets a user-defined object that qualifies or contains information about an asynchronous operation.</summary>
        </member>
        <member name="P:System.Threading.Tasks.TaskToApm.TaskAsyncResult.CompletedSynchronously">
            <summary>Gets a value that indicates whether the asynchronous operation completed synchronously.</summary>
            <remarks>This is set lazily based on whether the <see cref="F:System.Threading.Tasks.TaskToApm.TaskAsyncResult._task"/> has completed by the time this object is created.</remarks>
        </member>
        <member name="P:System.Threading.Tasks.TaskToApm.TaskAsyncResult.IsCompleted">
            <summary>Gets a value that indicates whether the asynchronous operation has completed.</summary>
        </member>
        <member name="P:System.Threading.Tasks.TaskToApm.TaskAsyncResult.AsyncWaitHandle">
            <summary>Gets a <see cref="T:System.Threading.WaitHandle"/> that is used to wait for an asynchronous operation to complete.</summary>
        </member>
        <member name="M:System.Threading.AsyncLock.LockAsync">
            <summary>
            Не бросает исключения.
            </summary>
        </member>
    </members>
</doc>
